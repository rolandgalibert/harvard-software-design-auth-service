/*
 * KnowledgeGraph
 * 
 * Version 1.0
 * 
 * September 16, 2014
 * 
 * Written by Roland L. Galibert for Harvard Extension course
 * CSCI E-97 Software Design: Principles, Models, and Patterns
 * Assignment #1.
 */
package cscie97.asn4.knowledge.engine;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

/**
 * This class maintains a knowledge graph that contain nodes and relationships
 * between those nodes (known as predicates). The graph is generated by capturing
 * information from input "triples" consisting of a subject, predicate and object
 * where the subject and object are both saved as graph nodes.
 * 
 * The graph also maintains a set of potential queries and triple sets that match
 * those queries. These are computed in advance in order to vastly improve
 * query performance.
 * 
 * KnowledgeGraph is implemented as a singleton, more specifically the
 * "Initialization-on-demand holder idiom" singleton as described in the
 * Wikipedia article "Singleton pattern".
 * 
 * Please see the assignment design document for more details.
 *
 * @author Roland L. Galibert
 * @version 1.0
 */
public class KnowledgeGraph {

    /**
     * Set of nodes in the knowledge graph.
     */
    private NodeMap nodeMap = new NodeMap();
    
    /**
     * Set of predicates in the knowledge graph.
     */
    private PredicateMap predicateMap = new PredicateMap();
    
    /**
     * Set of triples in the knowledge graph.
     */
    private TripleMap tripleMap = new TripleMap();
    
    /**
     * Set of pre-computed queries/triple matches over knowledge graph.
     */
    private QuerySetMap queryMapSet = new QuerySetMap();
    
    /*
     * Private hidden singleton constructor.
     */
    private KnowledgeGraph() {
    }

    /**
     * SingletonHolder is loaded on the first execution of
     * Singleton.getInstance() or the first access to SingletonHolder.INSTANCE,
     * not before.
     */
    private static class KnowledgeGraphHolder {

        private static final KnowledgeGraph KNOWLEDGE_GRAPH_INSTANCE = new KnowledgeGraph();
    }

    /**
     * Returns singleton object instance.
     * 
     * @return Singleton KnowledgeGraph object.
     */
    public static KnowledgeGraph getInstance() {
        return KnowledgeGraphHolder.KNOWLEDGE_GRAPH_INSTANCE;
    }

    /**
     * Creates new node, predicate and triple objects, if necessary, for the 
     * triple that is input as subject, predicate and object identifiers,
     * and updates class maps, including adding possible queryMapSet queries that would return
     * that tripleand adding the given triple as a match for the related queries
     * in that map.
     * 
     * @param subject Triple subject.
     * @param predicate Triple predicate.
     * @param object Triple object.
     */
    public void importTriple(String subject, String predicate, String object) {

        /*
         * Add subject, predicate and object as well as actual triple
         */
        Triple triple = getTriple(getNode(subject), getPredicate(predicate), getNode(object));

        /*
         * Updates queryMapSet of pre-computed queries/triple matches, also 
         * pre-computing queries that include ? wildcards
         */
        updateQueryMapSet(subject + " " + predicate + " " + object, triple);
        updateQueryMapSet("? " + predicate + " " + object, triple);
        updateQueryMapSet(subject + " ? " + object, triple);
        updateQueryMapSet(subject + " " + predicate + " ?", triple);
        updateQueryMapSet("? ? " + object, triple);
        updateQueryMapSet("? " + predicate + " ?", triple);
        updateQueryMapSet(subject + " ? ?", triple);
        updateQueryMapSet("? ? ?", triple);
    }

    /**
     * Updates queryMapSet of pre-computed queries/triple matches
     * 
     * @param identifier Query string identifier
     * @param triple Matching triple
     */
    public void updateQueryMapSet(String identifier, Triple triple) {
        if (queryMapSet.get(identifier) == null) {
            queryMapSet.put(identifier, new HashSet<Triple>());
            queryMapSet.get(identifier).add(triple);
        } else {
            if (!queryMapSet.get(identifier).contains(triple)) {
               queryMapSet.get(identifier).add(triple);
            }
        }
    }
    

    /**
     * Executes given query
     * 
     * @param query Triple object.
     * @return Set of triples which match input query.
     */
    public Set<Triple> executeQuery(Triple query) {
        return queryMapSet.get(query.getIdentifier());
     }

    /**
     * Returns Node object with given identifier. If a node with that identifier
     * doesn't already exist, the method creates a new Node object and updates
     * the class nodeMap.
     * 
     * @param identifier
     * @return Node object.
     */
    public Node getNode(String identifier) {
        Node node = nodeMap.get(identifier);
        if (node == null) {
            node = new Node(identifier);
            nodeMap.put(identifier, node);
        }
        return node;
    }

    /**
     * Returns Predicate object with given identifier. If a predicate with that identifier
     * doesn't already exist, the method creates a new Predicate object and updates
     * the class predicateMap.
     * 
     * @param identifier
     * @return Predicate object.
     */
    public Predicate getPredicate(String identifier) {
        Predicate predicate = predicateMap.get(identifier);
        if (predicate == null) {
            predicate = new Predicate(identifier);
            predicateMap.put(identifier, predicate);
        }
        return predicate;
    }

    /**
     * Returns Triple object with given Node (subject and object) and Predicate
     * objects. If a triple with those elements doesn't already exist, the method
     * creates a new Triple object and updates the class tripleMap.
     * 
     * @param subject Node object.
     * @param predicate Predicate object.
     * @param object Node object.
     * @return Triple object matching input parameters.
     */
    public Triple getTriple(Node subject, Predicate predicate, Node object) {

        String tripleMapIdentifier = subject.getIdentifier() + " "
                + predicate.getIdentifier() + " "
                + object.getIdentifier();

        Triple triple = tripleMap.get(tripleMapIdentifier);
        if (triple == null) {
            triple = new Triple(subject.getIdentifier().concat(" ").concat(predicate.getIdentifier()).concat(" ").concat(object.getIdentifier()), 
                    subject, predicate, object);
            tripleMap.put(tripleMapIdentifier, triple);
        }
        return triple;
    }

    /**
     * Returns Triple object with given identifiers. If a triple with that identifier
     * doesn't already exist, the method creates a new Triple object and updates
     * the class tripleMap.
     * 
     * @param subjectIdentifier String identifier for subject Node.
     * @param predicateIdentifier String identifier for Predicate object.
     * @param objectIdentifier String identifier for object Node.
     * @return Triple object matching input parameters.
     */
    public Triple getTriple(String subjectIdentifier, String  predicateIdentifier, String objectIdentifier) {

        String tripleMapIdentifier = subjectIdentifier + " "
                + predicateIdentifier + " "
                + objectIdentifier;

        Triple triple = tripleMap.get(tripleMapIdentifier);
        if (triple == null) {
            triple = new Triple(subjectIdentifier.concat(" ").concat(predicateIdentifier).concat(" ").concat(objectIdentifier), 
                    getNode(subjectIdentifier), getPredicate(predicateIdentifier), getNode(objectIdentifier));
            tripleMap.put(tripleMapIdentifier, triple);
        }
        return triple;
    }
    
    /**
     * Removes the specified subject from the KnowledgeGraph, by deleting all
     * Triples that contain that subject from the tripleMap and deleting all
     * queries that map to triples containing the subject from the map of
     * pre-formed queries/corresponding triple sets.
     * 
     * @param subjectIdentifier Description of subject to be deleted.
     */
    public void removeSubjectFromKnowledgeGraph(String subjectIdentifier) {
        
        /**
         * Remove triples that start with subject from triple map.
         */
        Object[] tripleKeys = tripleMap.keySet().toArray();
        for (int i = 0; i < tripleKeys.length; i++) {
            String currentKey = (String) tripleKeys[i];
            if (currentKey.startsWith(subjectIdentifier + " ")) {
                tripleMap.remove(currentKey);
            }
        }
        
        Object[] queryMapSetKeys = queryMapSet.keySet().toArray();
        for (int i = 0; i < queryMapSetKeys.length; i++) {
            HashSet<Triple> tripleSet = queryMapSet.get(queryMapSetKeys[i]);
            Iterator<Triple> iterator = tripleSet.iterator();
            while (iterator.hasNext()) {
                Triple currentTriple = iterator.next();
                if (currentTriple.getSubject().getIdentifier().equals(subjectIdentifier)) {
                    iterator.remove();
                }
            }
        }
    }
}
